# EVALUATION: Parameter Naming Standardization

**Topic:** Parameter Naming Standardization
**Date:** 2026-01-20
**Analysis Timestamp:** 20260120-095000
**Verdict:** CONTINUE (LOW-MEDIUM effort, already mostly correct)

---

## EXECUTIVE SUMMARY

Parameter naming across cherry-chrome-mcp is **already well-standardized**. All 40+ tools consistently use snake_case for MCP parameter definitions and camelCase for internal TypeScript implementation. The opportunity for improvement is not fixing broken naming, but rather:

1. **Centralizing enforcement** to prevent future drift
2. **Documenting the convention** explicitly
3. **Adding validation** at the MCP boundary

**Current State:** Excellent separation of concerns - snake_case at MCP boundary, camelCase internally
**Desired State:** Automated enforcement + explicit documentation
**Effort:** LOW (documentation + validation layer, not fixing existing code)

---

## PART 1: WHAT EXISTS

### 1.1 Current Parameter Naming Conventions

**MCP Tool Definitions (snake_case) ✓**

All tool schemas in `src/index.ts:73-897` use snake_case consistently:

```typescript
// Example from queryElements (lines 75-106)
properties: {
  selector: { type: 'string' },
  limit: { type: 'number' },
  text_contains: { type: 'string' },
  include_hidden: { type: 'boolean' },
  connection_id: { type: 'string' },
}

// Example from debuggerSetBreakpoint (legacy)
properties: {
  url: { type: 'string' },
  line_number: { type: 'number' },
  column_number: { type: 'number' },
  condition: { type: 'string' },
  connection_id: { type: 'string' },
}

// Example from inspectElement
properties: {
  description: { type: 'string' },
  text_contains: { type: 'string' },
  tag: { type: 'string' },
  attributes: {
    type: 'object',
    properties: {
      role: { type: 'string' },
      aria_label: { type: 'string' },
      data_testid: { type: 'string' },
      placeholder: { type: 'string' },
    }
  },
  strict_stability: { type: 'boolean' },
  connection_id: { type: 'string' },
}
```

**Tool Function Signatures (snake_case) ✓**

All 40+ tool implementations accept snake_case parameters:

```typescript
// src/tools/dom.ts:41-52
export async function queryElements(args: {
  selector: string;
  limit?: number;
  text_contains?: string;
  include_hidden?: boolean;
  connection_id?: string;
}): Promise<ToolResult>

// src/tools/chrome.ts:76-83
export async function chrome(args: {
  action: 'connect' | 'launch';
  port?: number;
  host?: string;
  connection_id?: string;
  headless?: boolean;
  user_data_dir?: string;
  extra_args?: string;
}): Promise<ToolResult>

// src/tools/debugger.ts:45-52
export async function debuggerSetBreakpoint(args: {
  url: string;
  line_number: number;
  column_number?: number;
  condition?: string;
  connection_id?: string;
}): Promise<ToolResult>
```

**Internal Implementation (camelCase where appropriate) ✓**

Tools convert to camelCase for internal variables when needed:

```typescript
// src/tools/dom.ts:52-57 (queryElements)
const page = browserManager.getPageOrThrow(args.connection_id);
const textContainsFilter = args.text_contains;  // Converted to camelCase
const includeHidden = args.include_hidden ?? false;  // Converted to camelCase

// src/tools/debugger.ts:50-51 (debuggerSetBreakpoint)
await cdpSession.send('Debugger.setBreakpointByUrl', {
  url: args.url,
  lineNumber: args.line_number - 1,  // CDP uses camelCase + adjustment
  columnNumber: args.column_number ?? 0,  // CDP uses camelCase
  condition: args.condition,
});
```

### 1.2 Parameter Coverage Across Tools

**Shared Parameters (appear in 10+ tools):**
- `connection_id` - Present in all tools that interact with Chrome (37 tools)
- `include_context` - Present in action tools (click, fill, navigate, step, execution)
- `selector` - Present in DOM interaction tools (query, click, fill)

**Mode-Specific Parameters:**
- **Legacy only:** `url`, `line_number`, `column_number` (debugger tools)
- **Smart only:** `action`, `direction`, `state` (consolidated tools)

**CDP Conversion Parameters:**
- `line_number` → `lineNumber` (CDP expects camelCase)
- `column_number` → `columnNumber` (CDP expects camelCase)
- `call_frame_id` → `callFrameId` (CDP expects camelCase)
- `breakpoint_id` → `breakpointId` (CDP expects camelCase)

### 1.3 Naming Consistency Analysis

**✓ CONSISTENT: All Tool Definitions**
- 100% of tools use snake_case in MCP schema
- 100% of tool function signatures accept snake_case
- 0 naming violations detected

**✓ CORRECT: CDP Integration**
- Chrome DevTools Protocol (CDP) uses camelCase natively
- Tool implementations correctly convert snake_case → camelCase for CDP calls
- Example: `line_number` (MCP) → `lineNumber` (CDP)

**✓ APPROPRIATE: Internal TypeScript**
- TypeScript variables use camelCase convention
- No forced snake_case in implementation code
- Clear separation: external API (snake_case) vs internal (camelCase)

---

## PART 2: WHAT'S MISSING

### 2.1 Centralized Parameter Normalization

**Current Pattern:**
Each tool manually extracts parameters and performs its own conversions:

```typescript
// Repeated pattern in 40+ tools
export async function someTool(args: {
  connection_id?: string;
  some_param?: string;
}): Promise<ToolResult> {
  const page = browserManager.getPageOrThrow(args.connection_id);
  const someValue = args.some_param;
  // ... implementation
}
```

**Missing Infrastructure:**
- No `normalizeArgs()` wrapper at MCP boundary
- No parameter validation layer to catch typos
- No automated enforcement of snake_case convention
- No schema-to-type validation

### 2.2 Explicit Documentation

**Current State:**
- Naming convention is followed but not documented
- No written specification for parameter naming rules
- No guidance for adding new tools
- No explanation of snake_case (MCP) vs camelCase (internal) separation

**Missing Documentation:**
- CLAUDE.md section on parameter naming convention
- README.md note about MCP SDK snake_case standard
- Code comments explaining conversion strategy
- Contributing guidelines for new tool parameters

### 2.3 Automated Enforcement

**Current State:**
- TypeScript validates parameter types but not names
- No linter rules for parameter naming
- No CI checks for naming convention violations
- No runtime validation of parameter names

**Missing Enforcement:**
- ESLint rule: Enforce snake_case in tool parameter interfaces
- TypeScript type guard: Validate args match schema
- Runtime validation: Warn on unknown parameters
- CI check: Fail if new tools violate convention

---

## PART 3: WHAT NEEDS CHANGES

### 3.1 Files NOT Requiring Changes

**Good News:** 99% of existing code is already correct!

**src/tools/*.ts (All tool implementations):**
- ✓ All use snake_case parameters correctly
- ✓ CDP conversions are appropriate
- ✓ Internal variable naming follows TypeScript conventions
- **Action:** NO CHANGES NEEDED

**src/index.ts (Tool definitions):**
- ✓ All 40+ tools defined with snake_case parameters
- ✓ Consistent schema structure
- **Action:** NO CHANGES NEEDED (except add validation)

### 3.2 Files Requiring Documentation

**CLAUDE.md (Project instructions):**
- **Add section:** "Parameter Naming Convention"
- Document snake_case for MCP parameters
- Explain camelCase for internal TypeScript
- Provide CDP conversion examples

**README.md (User-facing docs):**
- **Add note:** "Parameters follow MCP SDK snake_case convention"
- Reference CLAUDE.md for developer details

### 3.3 Files Requiring New Functionality

**src/utils/parameterValidation.ts (NEW):**
- Create parameter validation utilities
- Implement schema-to-args comparison
- Add runtime warnings for unknown parameters

**src/index.ts (Modify CallToolRequestSchema handler):**
- Add optional parameter validation before tool invocation
- Log warnings for unexpected parameters
- Preserve existing behavior (non-breaking)

---

## PART 4: DEPENDENCIES AND RISKS

### 4.1 Dependencies

**Tool Registry Implementation (cherry-chrome-mcp-2br):**
- Parameter validation fits naturally in registry handler
- Registry can intercept args before invoking tool
- Best implemented AFTER registry pattern complete

**TypeScript Type System:**
- Already enforces parameter types
- Can be extended to validate parameter names
- No additional dependencies needed

### 4.2 Risks

**Risk 1: Breaking Existing Behavior**
- **Severity:** LOW
- **Likelihood:** LOW
- **Impact:** Validation is additive, not modifying existing code
- **Mitigation:** Make validation opt-in or warning-only initially

**Risk 2: False Positives**
- **Severity:** LOW
- **Likelihood:** MEDIUM
- **Impact:** Validation may flag valid but unexpected parameters
- **Mitigation:** Whitelist known exceptions, log warnings instead of errors

**Risk 3: Maintenance Burden**
- **Severity:** LOW
- **Likelihood:** LOW
- **Impact:** New tools require documentation updates
- **Mitigation:** Automated linting catches violations early

---

## PART 5: AMBIGUITIES AND UNKNOWNS

### 5.1 Validation Scope

**Question:** Where should parameter validation happen?

**Option A: In CallToolRequestSchema Handler (Recommended)**
```typescript
server.setRequestHandler(CallToolRequestSchema, async (request) => {
  const { name, arguments: args = {} } = request.params;

  // Validate parameters before tool invocation
  const warnings = validateToolParameters(name, args);
  if (warnings.length > 0) {
    console.warn(`[PARAM_WARNING] tool=${name}`, warnings);
  }

  // Continue with normal tool routing
  const handler = toolRegistry.getHandler(name);
  return await handler.invoke(args);
});
```

**Pros:**
- Single validation point (SINGLE ENFORCER)
- Non-breaking (warnings only)
- Easy to disable for performance

**Cons:**
- Adds latency to every tool call
- May log too many warnings

**Option B: In Tool Registry Handler**
```typescript
// In toolRegistry.ts
invoke: async (args: unknown) => {
  validateArgs(args, definition.inputSchema);
  return await toolFunction(args as ToolArgs);
}
```

**Pros:**
- Validation close to execution
- Can be per-tool opt-in

**Cons:**
- Duplicated across 40 handlers
- Violates DRY principle

**Option C: No Runtime Validation (Recommended for MVP)**
- Rely on TypeScript type checking
- Add ESLint rules for enforcement
- Document convention only
- Lowest risk, lowest overhead

**Recommendation:** Option C for MVP, then Option A if validation needed

### 5.2 CDP Parameter Conversion

**Question:** Should we standardize CDP parameter conversion?

**Current State:**
Each tool converts manually:
```typescript
// Tool: debuggerSetBreakpoint
await cdpSession.send('Debugger.setBreakpointByUrl', {
  url: args.url,
  lineNumber: args.line_number - 1,  // Manual conversion
  columnNumber: args.column_number ?? 0,
});
```

**Option A: Keep Manual Conversion (Recommended)**
- **Pro:** Explicit and clear
- **Pro:** Each tool handles its own CDP mapping
- **Con:** Duplicated conversion logic

**Option B: Create CDP Parameter Converter**
```typescript
function toCDP(args: Record<string, any>): Record<string, any> {
  return Object.entries(args).reduce((acc, [key, value]) => {
    const camelKey = key.replace(/_([a-z])/g, (_, letter) => letter.toUpperCase());
    acc[camelKey] = value;
    return acc;
  }, {} as Record<string, any>);
}
```
- **Pro:** Reusable utility
- **Pro:** Consistent conversion
- **Con:** Magic conversion may hide bugs
- **Con:** Not all parameters need conversion

**Recommendation:** Option A (keep manual) - explicit is better than implicit

### 5.3 Nested Object Parameters

**Question:** How to handle nested object parameters?

**Example:** inspectElement has nested attributes
```typescript
properties: {
  attributes: {
    type: 'object',
    properties: {
      role: { type: 'string' },
      aria_label: { type: 'string' },  // snake_case
      data_testid: { type: 'string' },  // snake_case
    }
  }
}
```

**Current Implementation:** Already correct (snake_case in nested objects)

**Decision:** No changes needed

---

## PART 6: RECOMMENDED IMPLEMENTATION

### Phase 1: Documentation (HIGH PRIORITY, LOW EFFORT)

**Effort:** 1-2 hours

**Tasks:**
1. Add "Parameter Naming Convention" section to CLAUDE.md
2. Document snake_case for MCP parameters
3. Explain camelCase for internal TypeScript
4. Provide CDP conversion examples
5. Add contributing guidelines for new tools

**Deliverable:** Updated CLAUDE.md and README.md

### Phase 2: Optional Validation (LOW PRIORITY, MEDIUM EFFORT)

**Effort:** 2-3 hours (if needed)

**Tasks:**
1. Create src/utils/parameterValidation.ts
2. Implement validateToolParameters() function
3. Add optional validation in CallToolRequestSchema handler
4. Log warnings for unexpected parameters

**Deliverable:** Parameter validation utility (opt-in)

### Phase 3: Automated Enforcement (MEDIUM PRIORITY, MEDIUM EFFORT)

**Effort:** 2-3 hours

**Tasks:**
1. Add ESLint rule for snake_case in tool parameter interfaces
2. Create pre-commit hook to check parameter naming
3. Add CI check for naming convention violations

**Deliverable:** Automated linting and CI checks

---

## PART 7: DESIGN DECISIONS

| Decision | Recommendation | Rationale |
|----------|---------------|-----------|
| Validation location | Option C (No runtime validation for MVP) | Lowest risk, TypeScript already validates |
| CDP conversion | Keep manual (Option A) | Explicit conversions are clearer |
| Nested parameters | No changes needed | Already correct |
| Documentation | HIGH PRIORITY | Prevents future drift |
| Enforcement | ESLint + CI (Phase 3) | Automated, non-breaking |

---

## VERDICT: CONTINUE (Documentation Sprint)

**Confidence Level:** HIGH (code already correct, just needs documentation)

**Recommendation:** Implement as a **documentation sprint** rather than a code refactoring sprint

**Effort Estimate:**
- Phase 1 (Documentation): 1-2 hours
- Phase 2 (Optional Validation): 2-3 hours (defer)
- Phase 3 (Automated Enforcement): 2-3 hours (defer)

**Total Minimum Effort:** 1-2 hours (documentation only)

**Next Steps:**
1. Document parameter naming convention in CLAUDE.md
2. Add contributing guidelines
3. Update README.md with parameter convention note
4. (Optional) Add ESLint rules for enforcement

**Expected Outcome:** Formalized parameter naming convention with documented guidelines to prevent future drift, without modifying any existing code.

---

**Evaluation Date:** 2026-01-20
**Timestamp:** 20260120-095000
**Evaluator:** Code Analysis
**Next Review:** After documentation complete
