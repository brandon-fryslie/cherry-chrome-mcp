# Sprint Plan: Port Python chrome-debugger-mcp to TypeScript

Generated: 2026-01-12

## Sprint Goal

Port all 22 tools from the Python chrome-debugger-mcp wrapper to TypeScript using Puppeteer, maintaining multi-instance support and full debugger functionality.

## Scope

**In scope (this sprint):**
1. Browser & connection management with multi-instance support
2. All 5 DOM interaction tools (query_elements, click_element, fill_element, navigate, get_console_logs)
3. All 5 Chrome connection tools (chrome_connect, chrome_launch, chrome_list_connections, chrome_switch_connection, chrome_disconnect)
4. All 11 debugger tools (enable, breakpoints, stepping, evaluation, call stack, exception handling)
5. Response formatting with smart size analysis and DOM depth filtering

**Explicitly out of scope (future sprints):**
- Performance tracing (not in Python implementation)
- Screenshot tools (not in Python implementation)
- Network request interception beyond simple listing
- Auto-connect on startup

## Work Items

### P0: Browser & Connection Management

Create `src/browser.ts` - Multi-instance browser connection manager.

**Files to create:**
- `src/browser.ts` - BrowserManager class
- `src/types.ts` - Shared types

**Technical Approach:**
- Each `connection_id` maps to a separate Chrome instance launched via Puppeteer
- Store both Browser and Page references per connection
- Track active connection for default tool operations
- Use Puppeteer's `puppeteer.connect()` for existing instances
- Use `puppeteer.launch()` for new instances with platform-specific Chrome detection

**Key Types:**
```typescript
interface Connection {
  browser: Browser;
  page: Page;
  wsUrl: string;
  pausedData: DebuggerPausedEvent | null;
  breakpoints: Map<string, BreakpointInfo>;
}

class BrowserManager {
  connections: Map<string, Connection>;
  activeConnectionId: string | null;
  // Methods mirror CDPConnectionManager from Python
}
```

### P1: Response Formatting

Create `src/response.ts` - Result size checking and smart analysis.

**Files to create:**
- `src/response.ts` - Response utilities
- `src/config.ts` - Configuration constants

**Technical Approach:**
- Port MAX_RESULT_SIZE = 5000, MAX_DOM_DEPTH = 3, HARD_MAX_DOM_DEPTH = 10
- `checkResultSize()` - Reject (don't truncate) oversized results
- `analyzeQueryElementsData()` - Suggest narrowing based on classes/IDs found
- Generic suggestions for console_logs, network_requests, execute_script

### P2: DOM Interaction Tools

Create `src/tools/dom.ts` - CSS selector-based DOM tools.

**Technical Approach:**
- Use `page.evaluate()` for JavaScript execution (same as Python's chrome_client.evaluate)
- Port depth filtering logic exactly from Python
- `query_elements`: Execute JS to collect element data with depth filtering
- `click_element`: Use `page.$(selector)` + `element.click()` with JavaScript fallback
- `fill_element`: Use `page.$(selector)` + `element.type()` with event dispatch
- `navigate`: Use `page.goto()` with networkidle2 wait
- `get_console_logs`: Collect console messages (may need Puppeteer event listener)

**DOM Depth Filtering (from Python):**
```typescript
// JavaScript to execute in page context
function getDepth(el: Element): number {
  let depth = 0;
  let current = el;
  while (current && current !== document.body) {
    depth++;
    current = current.parentElement;
  }
  return depth;
}
```

### P3: Chrome Connection Tools

Create `src/tools/chrome.ts` - Connection management tools.

**Technical Approach:**
- `chrome_connect`: Use `puppeteer.connect({ browserURL: ... })`
- `chrome_launch`: Use `puppeteer.launch()` with platform detection
- `chrome_list_connections`: Format connection status
- `chrome_switch_connection`: Update activeConnectionId
- `chrome_disconnect`: Close browser, remove from map

**Platform-specific Chrome paths:**
- macOS: `/Applications/Google Chrome.app/Contents/MacOS/Google Chrome`
- Linux: `google-chrome`
- Windows: `C:\Program Files\Google\Chrome\Application\chrome.exe`

### P4: CDP Client & Debugger Tools

Create `src/tools/debugger.ts` - JavaScript debugger via CDP.

**Technical Approach:**
- Use `page._client` (Puppeteer's internal CDP client) or `page.client()`
- Set up event listeners for `Debugger.paused` and `Debugger.resumed`
- Store `pausedData` in Connection object for call stack retrieval

**CDP Commands Used:**
- `Debugger.enable` - Enable debugger domain
- `Debugger.setBreakpointByUrl` - Set breakpoints (0-indexed line numbers)
- `Debugger.evaluateOnCallFrame` - Evaluate in paused context
- `Debugger.stepOver/stepInto/stepOut` - Stepping
- `Debugger.resume/pause` - Execution control
- `Debugger.removeBreakpoint` - Cleanup
- `Debugger.setPauseOnExceptions` - Exception handling

**Line Number Conversion:**
- User input: 1-indexed
- CDP: 0-indexed
- Convert: `cdpLine = userLine - 1`, `userLine = cdpLine + 1`

### P5: Update Main Server

Update `src/index.ts` - Replace stubs with real implementations.

**Technical Approach:**
- Import BrowserManager and tool implementations
- Initialize BrowserManager on server start
- Replace switch/case stubs with actual tool calls
- Update tool schemas to match Python signatures exactly

## File Structure (Final)

```
src/
├── index.ts              # MCP server, tool registration
├── browser.ts            # BrowserManager class
├── config.ts             # Constants (MAX_RESULT_SIZE, etc.)
├── response.ts           # Result formatting utilities
├── types.ts              # Shared TypeScript types
└── tools/
    ├── index.ts          # Tool exports
    ├── chrome.ts         # Connection management (5 tools)
    ├── dom.ts            # DOM interaction (5 tools)
    └── debugger.ts       # Debugger (11 tools)
```

## Dependencies

- Puppeteer 24.x (already installed)
- @modelcontextprotocol/sdk (already installed)
- No new dependencies required

## Risks

1. **`page._client` API stability** - Undocumented, could change
   - Mitigation: Check Puppeteer 24.x source; wrap in try/catch

2. **Multi-instance browser lifecycle** - Each connection is a separate Chrome process
   - Mitigation: Track both Browser and Page; clean shutdown

3. **DOM depth filtering accuracy** - Must match Python behavior exactly
   - Mitigation: Port JavaScript code verbatim; test with same inputs

4. **CDP event timing** - `Debugger.paused` must be captured before tools query it
   - Mitigation: Set up event listeners immediately after enable

## Implementation Order

1. `src/config.ts` - Constants
2. `src/types.ts` - Type definitions
3. `src/browser.ts` - BrowserManager (foundation)
4. `src/response.ts` - Response utilities
5. `src/tools/chrome.ts` - Connection tools
6. `src/tools/dom.ts` - DOM tools
7. `src/tools/debugger.ts` - Debugger tools
8. `src/index.ts` - Wire everything together
