# Implementation Context: Python to TypeScript Port

Generated: 2026-01-12

## Source Reference: Python Implementation

**File:** `references/chrome-debugger-mcp/server.py`

### Key Classes

**CDPClient (lines 70-230):**
- Direct WebSocket connection to Chrome DevTools Protocol
- `connect(host, port)` - Discovery via `/json` endpoint, WebSocket connection
- `send_command(method, params)` - JSON-RPC with 10s timeout
- `_receive_loop()` - Background message listener
- `_handle_event()` - Stores `paused_data` for `Debugger.paused` events
- Properties: `ws`, `ws_url`, `msg_id`, `pending_responses`, `paused_data`, `breakpoints`

**CDPConnectionManager (lines 233-342):**
- Multi-instance connection management
- `connections: Dict[str, CDPClient]`
- `active_connection_id: Optional[str]`
- Methods: `connect()`, `disconnect()`, `disconnect_all()`, `get_active()`, `get()`, `switch_active()`, `list_connections()`, `get_connection()`

**ChromeDevToolsClient (lines 345-553):**
- MCP client wrapper (NOT needed in TypeScript - we use Puppeteer directly)
- Methods used: `evaluate()` â†’ maps to `page.evaluate()` in TypeScript
- `find_element_ref()` - NOT needed, we use CSS selectors directly

### Configuration (from config.py)

```python
MAX_RESULT_SIZE = 5000      # ~1250 tokens
MAX_DOM_DEPTH = 3           # Default depth filter
HARD_MAX_DOM_DEPTH = 10     # Absolute maximum
DEBUG = True
```

### Tool Signatures (from server.py)

**Chrome Connection Tools:**
```python
chrome_connect(port: int = 9222, connection_id: str = "default", host: str = "localhost")
chrome_launch(debug_port: int = 9222, headless: bool = False, user_data_dir: Optional[str] = None, extra_args: Optional[str] = None, connection_id: str = "auto")
chrome_list_connections() -> str
chrome_switch_connection(connection_id: str) -> str
chrome_disconnect(connection_id: str) -> str
```

**DOM Tools:**
```python
query_elements(selector: str, limit: int = 20, max_depth: Optional[int] = None, connection_id: Optional[str] = None)
click_element(selector: str, index: int = 0, connection_id: Optional[str] = None)
fill_element(selector: str, text: str, index: int = 0, submit: bool = False, connection_id: Optional[str] = None)
navigate(url: str, connection_id: Optional[str] = None)
get_console_logs(filter_level: str = "all", connection_id: Optional[str] = None)
```

**Debugger Tools:**
```python
debugger_enable(connection_id: Optional[str] = None)
debugger_set_breakpoint(url: str, line_number: int, column_number: int = 0, condition: Optional[str] = None, connection_id: Optional[str] = None)
debugger_get_call_stack(connection_id: Optional[str] = None)
debugger_evaluate_on_call_frame(call_frame_id: str, expression: str, connection_id: Optional[str] = None)
debugger_step_over(connection_id: Optional[str] = None)
debugger_step_into(connection_id: Optional[str] = None)
debugger_step_out(connection_id: Optional[str] = None)
debugger_resume(connection_id: Optional[str] = None)
debugger_pause(connection_id: Optional[str] = None)
debugger_remove_breakpoint(breakpoint_id: str, connection_id: Optional[str] = None)
debugger_set_pause_on_exceptions(state: str, connection_id: Optional[str] = None)
```

## Critical JavaScript Code (from Python server.py)

### DOM Depth Filtering (lines 970-1057)

```javascript
(() => {
    const maxDepth = ${max_depth};

    // Calculate depth from body
    function getDepth(el) {
        let depth = 0;
        let current = el;
        while (current && current !== document.body) {
            depth++;
            current = current.parentElement;
        }
        return depth;
    }

    // Count total descendants
    function countDescendants(el) {
        let count = 0;
        function countRecursive(node) {
            for (const child of node.children) {
                count++;
                countRecursive(child);
            }
        }
        countRecursive(el);
        return count;
    }

    // Get all matching elements
    const allElements = Array.from(document.querySelectorAll('${escaped_selector}'));

    // Filter by depth
    const elementsWithDepth = allElements.map(el => ({
        element: el,
        depth: getDepth(el)
    }));

    const filteredElements = elementsWithDepth.filter(item => item.depth <= maxDepth);
    const filtered = allElements.length - filteredElements.length;

    // Apply limit and extract data
    const limit = ${limit};
    const limitedElements = filteredElements.slice(0, limit);

    return {
        found: allElements.length,
        foundAfterDepthFilter: filteredElements.length,
        filteredByDepth: filtered,
        maxDepth: maxDepth,
        elements: limitedElements.map((item, idx) => {
            const el = item.element;
            const rect = el.getBoundingClientRect();

            // If this element is at max depth, count its children
            let childInfo = null;
            if (item.depth === maxDepth && el.children.length > 0) {
                childInfo = {
                    directChildren: el.children.length,
                    totalDescendants: countDescendants(el)
                };
            }

            return {
                index: idx,
                selector: '${escaped_selector}',
                tag: el.tagName.toLowerCase(),
                text: el.textContent.trim().substring(0, 100),
                id: el.id || null,
                classes: el.className ? el.className.split(' ').filter(c => c) : [],
                visible: el.offsetParent !== null,
                depth: item.depth,
                childInfo: childInfo,
                position: {
                    x: Math.round(rect.x),
                    y: Math.round(rect.y),
                    width: Math.round(rect.width),
                    height: Math.round(rect.height)
                },
                attributes: {
                    type: el.type || null,
                    name: el.name || null,
                    placeholder: el.placeholder || null,
                    value: el.value !== undefined ? el.value.substring(0, 100) : null
                }
            };
        })
    };
})()
```

### Click Element Fallback (lines 1152-1182)

```javascript
(() => {
    const elements = document.querySelectorAll('${escaped_selector}');
    if (elements.length === 0) {
        return { success: false, error: 'No elements found matching selector' };
    }
    if (${index} >= elements.length) {
        return { success: false, error: `Only ${elements.length} element(s) found, index ${index} out of range` };
    }

    const element = elements[${index}];
    element.click();

    return {
        success: true,
        clicked: `<${element.tagName.toLowerCase()}> at index ${index}`,
        text: element.textContent.trim().substring(0, 50)
    };
})()
```

### Fill Element with Events (lines 1236-1268)

```javascript
(() => {
    const elements = document.querySelectorAll('${escaped_selector}');
    if (elements.length === 0) {
        return { success: false, error: 'No elements found matching selector' };
    }
    if (${index} >= elements.length) {
        return { success: false, error: `Only ${elements.length} element(s) found, index ${index} out of range` };
    }

    const element = elements[${index}];

    // Set value
    element.value = '${escaped_text}';

    // Trigger input event
    element.dispatchEvent(new Event('input', { bubbles: true }));
    element.dispatchEvent(new Event('change', { bubbles: true }));

    // Submit if requested
    if (${submit}) {
        element.dispatchEvent(new KeyboardEvent('keypress', { key: 'Enter', code: 'Enter', keyCode: 13, bubbles: true }));
    }

    return {
        success: true,
        filled: `<${element.tagName.toLowerCase()}> at index ${index}`,
        type: element.type || 'text'
    };
})()
```

## TypeScript Patterns (from reference-chrome-devtools-mcp)

### Accessing CDP via Puppeteer

```typescript
// Reference: src/tools/script.ts line 65-80
const result = await page.evaluate(
  async (fn, ...args) => {
    return JSON.stringify(await fn(...args));
  },
  ...args,
);
```

### Browser Connection (from src/browser.ts)

```typescript
// Connect to existing Chrome
const browser = await puppeteer.connect({
  browserURL: `http://localhost:${port}`,
  targetFilter: makeTargetFilter(),
  defaultViewport: null,
});

// Launch new Chrome
const browser = await puppeteer.launch({
  channel: 'chrome',
  executablePath: customPath,
  headless,
  userDataDir,
  args: ['--remote-debugging-port=9222'],
});
```

### CDP Access Pattern

```typescript
// Get CDP client from page
const client = page.client();  // Preferred in newer Puppeteer
// or
const client = (page as any)._client;  // Fallback

// Send CDP command
await client.send('Debugger.enable');
const result = await client.send('Debugger.setBreakpointByUrl', {
  url: 'http://localhost:3000/app.js',
  lineNumber: 41,  // 0-indexed
});

// Listen for CDP events
client.on('Debugger.paused', (params) => {
  // Store params for call stack retrieval
  connection.pausedData = params;
});

client.on('Debugger.resumed', () => {
  connection.pausedData = null;
});
```

## Response Formatting (from Python lines 578-697)

### analyze_query_elements_data()

```python
def analyze_query_elements_data(elements_json: dict) -> str:
    elements = elements_json.get('elements', [])
    if not elements:
        return "No elements found"

    # Collect class, id, and tag data
    classes = []
    ids = []
    tags = []

    for el in elements:
        if el.get('classes'):
            classes.extend(el['classes'])
        if el.get('id'):
            ids.append(el['id'])
        if el.get('tag'):
            tags.append(el['tag'])

    suggestions = []
    total = len(elements)
    suggestions.append(f"Found {total} elements. Here's how to narrow it down:")

    # Suggest specific classes (most common)
    if classes:
        class_counts = {}
        for c in classes:
            class_counts[c] = class_counts.get(c, 0) + 1
        top_classes = sorted(class_counts.items(), key=lambda x: x[1], reverse=True)[:3]
        class_suggestions = [f'.{c[0]} ({c[1]} elements)' for c in top_classes]
        suggestions.append(f"  Most common classes: {', '.join(class_suggestions)}")

    # ... more suggestions
```

### check_result_size()

```python
def check_result_size(result: str, max_size: int = MAX_RESULT_SIZE, context: str = "", analysis_data: Any = None) -> str:
    if len(result) <= max_size:
        return result

    # Result is too large - provide smart suggestions
    size_kb = len(result) / 1024
    limit_kb = max_size / 1024

    # Perform deterministic analysis if we have structured data
    smart_analysis = ""
    if context == "query_elements" and analysis_data:
        smart_analysis = analyze_query_elements_data(analysis_data)
    else:
        # Generic suggestions dict...
```

## MCP SDK Patterns (from current src/index.ts)

```typescript
import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import {
  CallToolRequestSchema,
  ListToolsRequestSchema,
} from '@modelcontextprotocol/sdk/types.js';

const server = new Server(
  { name: 'cherry-chrome-mcp', version: '0.1.0' },
  { capabilities: { tools: {} } }
);

// Tool list handler
server.setRequestHandler(ListToolsRequestSchema, async () => ({
  tools: [
    {
      name: 'tool_name',
      description: 'Tool description',
      inputSchema: {
        type: 'object',
        properties: { /* ... */ },
        required: ['param1'],
      },
    },
  ],
}));

// Tool execution handler
server.setRequestHandler(CallToolRequestSchema, async (request) => {
  const { name, arguments: args = {} } = request.params;
  // Implementation...
  return {
    content: [{ type: 'text', text: 'Result' }],
  };
});
```

## Key Implementation Notes

1. **Line numbers**: Python uses 1-indexed, CDP uses 0-indexed. Convert at tool boundary.

2. **Connection ID default**: Use `"default"` for single-connection workflows.

3. **Timeout**: CDP commands use 10 second timeout (from Python line 220).

4. **Error format**: Include context and suggestions in error messages.

5. **Elision messages**: Format exactly as Python: `[ELIDED N DIRECT CHILD ELEMENTS (M elements total). INCREASE SELECTOR SPECIFICITY]`

6. **CDP event storage**: Store entire `params` object from `Debugger.paused` for call stack.

7. **Selector escaping**: Escape single quotes in CSS selectors for JavaScript strings.
