# EVALUATION: Tool Registry Pattern Implementation

**Topic:** Tool Registry Pattern Implementation
**Date:** 2026-01-20
**Analysis Timestamp:** 20260120-093519
**Verdict:** CONTINUE (HIGH confidence path, multiple design options)

---

## EXECUTIVE SUMMARY

The current tool routing implementation in `src/index.ts` (lines 1010-1182) uses a massive feature-toggle-driven switch statement to route 40 tools across two modes (legacy 23 tools, smart 17 tools). A tool registry pattern would decouple tool routing from the main server handler, improving extensibility, testability, and maintainability. However, the implementation must carefully preserve the existing feature toggle mechanism (`USE_LEGACY_TOOLS`), error handling infrastructure, and type safety guarantees.

**Current State:** Monolithic routing with good error classification and handling, but poor extensibility.
**Desired State:** Registry-based routing enabling dynamic tool registration, easier testing, and cleaner separation of concerns.
**Ambiguities:** Design choice between eager vs. lazy initialization, registry vs. metadata-driven approach, and integration with existing error handling.

---

## PART 1: WHAT EXISTS

### 1.1 Current Tool Routing Implementation

**Location:** `src/index.ts:1010-1182` (172 lines)

The router is a single `CallToolRequestSchema` handler with two parallel switch statements:

```typescript
server.setRequestHandler(CallToolRequestSchema, async (request) => {
  const { name, arguments: args = {} } = request.params;
  try {
    if (USE_LEGACY_TOOLS) {
      // Legacy tools switch: lines 1016-1114 (98 lines)
      switch (name) {
        case 'chrome_connect': return await chromeConnect(...);
        case 'chrome_launch': return await chromeLaunch(...);
        // ... 21 more cases
        default: throw new Error(`Unknown tool: ${name}`);
      }
    } else {
      // Smart tools switch: lines 1117-1182 (65 lines)
      switch (name) {
        case 'chrome': return await chrome(...);
        case 'target': return await target(...);
        // ... 15 more cases
        default: throw new Error(`Unknown tool: ${name}`);
      }
    }
  } catch (error) {
    // Error classification and handling: lines 1183-1204 (21 lines)
    const classified = classifyError(error, toolName, connectionId);
    logErrorEvent(classified);
    return { content: [...], isError: true, _toolName: toolName, ... };
  }
});
```

**Key Characteristics:**
- Direct name-to-implementation mapping in switch cases
- Type assertions for each tool: `args as Parameters<typeof toolName>[0]`
- Conditional routing based on `USE_LEGACY_TOOLS` boolean flag
- Global error catch wraps entire handler
- Error classification happens at routing boundary

### 1.2 Tool Metadata Structure

**Location:** `src/index.ts:73-333` (261 lines)

Tool definitions are organized in a `toolMetadata` object with category structure:

```typescript
const toolMetadata = {
  dom: {
    queryElements: { description: '...', inputSchema: {...} },
    clickElement: { ... },
    fillElement: { ... },
    navigate: { ... },
    getConsoleLogs: { ... },
    inspectElement: { ... },
  },
  connection: {
    chromeListConnections: { ... },
    chromeSwitchConnection: { ... },
    chromeDisconnect: { ... },
  },
};
```

**Characteristics:**
- Shared metadata for 8 tools used in both modes
- 3 category groups: `dom`, `connection` (and implicit debugger tools)
- No registry or lookup structure—purely declarative data
- Tool definitions spread into legacy and smart arrays
- No type mapping or handler registration

### 1.3 Tool Arrays (Legacy vs Smart)

**Locations:**
- `legacyTools`: `src/index.ts:338-641` (304 lines, 23 tools)
- `smartTools`: `src/index.ts:646-897` (252 lines, 17 tools)

**Structure:**

```typescript
const legacyTools: Tool[] = [
  { name: 'chrome_connect', description: '...', inputSchema: {...} },
  { name: 'chrome_launch', ... },
  // ... 21 more
];

const smartTools: Tool[] = [
  { name: 'chrome', description: '...', inputSchema: {...} },
  { name: 'target', ... },
  // ... 15 more
];

const activeTools = USE_LEGACY_TOOLS ? legacyTools : smartTools;
```

**Characteristics:**
- Arrays compiled at module load time
- No runtime registration mechanism
- Tool names are string literals (not enums or constants)
- Direct dependency on implementation imports (23+ tool functions)
- Passed directly to `server.setRequestHandler(ListToolsRequestSchema, ...)`

### 1.4 Error Handling Infrastructure

**Location:** `src/index.ts:903-980` (78 lines)

Error handling is centralized at the routing boundary with structured classification:

```typescript
interface ErrorInfo {
  readonly errorType: 'CONNECTION' | 'DEBUGGER' | 'STATE' | 'EXECUTION' | 'UNKNOWN';
  readonly recoverable: boolean;
  readonly suggestion?: string;
}

interface ClassifiedError {
  errorType: string;
  message: string;
  recoverable: boolean;
  suggestion?: string;
  toolName?: string;
  connectionId?: string;
}

function classifyError(error: unknown, toolName: string, connectionId?: string): ClassifiedError
function logErrorEvent(classified: ClassifiedError): void
```

**Key Properties:**
- Custom error classes in `src/errors.ts` implement `errorInfo` property
- Error types: CONNECTION, DEBUGGER, STATE, EXECUTION, UNKNOWN
- Recoverable flag indicates if user action can resolve
- Suggestions are tool-specific recovery instructions
- Logging includes error type, tool name, connection ID

**Error Flow:**
1. Tool throws custom error (e.g., `ChromeNotConnectedError`)
2. Global catch in handler captures error
3. `classifyError()` extracts metadata from error.errorInfo
4. `logErrorEvent()` writes structured log to stderr
5. Client receives error with metadata fields: `_toolName`, `_errorType`, `_recoverable`

### 1.5 Feature Toggle Mechanism

**Location:** `src/config.ts:47` and `src/index.ts:18, 900, 1014`

```typescript
// src/config.ts
export const USE_LEGACY_TOOLS = process.env.USE_LEGACY_TOOLS === 'true' || '1';

// src/index.ts
import { USE_LEGACY_TOOLS } from './config.js';
const activeTools = USE_LEGACY_TOOLS ? legacyTools : smartTools;

// In handler
if (USE_LEGACY_TOOLS) {
  switch (name) { /* legacy cases */ }
} else {
  switch (name) { /* smart cases */ }
}
```

**Characteristics:**
- Read from environment at module load (not runtime-switchable)
- Affects both tool listing and routing
- Requires server restart to change mode
- Two complete parallel implementations, not shared code

### 1.6 Tool Imports and Exports

**Location:** `src/tools/index.ts` (61 lines) and per-file exports

Imports in main `src/index.ts:22-56`:

```typescript
import {
  // Legacy chrome tools
  chromeConnect, chromeLaunch, chromeListConnections, chromeSwitchConnection,
  chromeDisconnect, listTargets, switchTarget,
  // Consolidated chrome tools
  chrome, target, enableDebugTools,
  // DOM tools
  queryElements, clickElement, fillElement, navigate, getConsoleLogs,
  inspectElement,
  // Legacy debugger tools
  debuggerEnable, debuggerSetBreakpoint, debuggerGetCallStack,
  debuggerEvaluateOnCallFrame, debuggerStepOver, debuggerStepInto,
  debuggerStepOut, debuggerResume, debuggerPause, debuggerRemoveBreakpoint,
  debuggerSetPauseOnExceptions,
  // Consolidated debugger tools
  step, execution, breakpoint, callStack, evaluate, pauseOnExceptions,
} from './tools/index.js';
```

**Characteristics:**
- All 40 tool functions imported at top of file
- No dynamic loading or lazy initialization
- Hard dependency on all tool modules being present
- No way to conditionally load tools
- Tool selection happens only in switch statements

---

## PART 2: WHAT'S MISSING

### 2.1 Tool Registry Module

**Does Not Exist:** `src/toolRegistry.ts`

**Current Workaround:** Tool registration is implicit in:
1. Tool metadata in `toolMetadata` object
2. Tool arrays in `legacyTools` / `smartTools`
3. Manual case statements in switch routing

**What's Missing:**
- Single authoritative registry mapping tool name → handler function
- Registry initialization/discovery mechanism
- Decoupling of tool metadata from tool routing
- Type-safe way to register tools
- Ability to add tools without modifying routing logic

### 2.2 Centralized Routing Logic

**Current Problem:** The switch statement pattern has inherent limitations:
- No way to add tools without modifying the handler function
- Difficult to test tool routing in isolation
- Tool lookup is O(n) not O(1)
- Hard to implement conditional tool availability
- No introspection into available tools at runtime

**Missing Features:**
- Registry lookup by tool name
- Middleware/interceptor mechanism for cross-cutting concerns
- Tool versioning support
- Conditional tool registration based on environment/capabilities
- Extensibility hook for plugins

### 2.3 Registry Initialization Strategy

**Current State:** Two parallel paths, no initialization:

```typescript
const legacyTools = [/* 23 tool objects */];
const smartTools = [/* 17 tool objects */];
const activeTools = USE_LEGACY_TOOLS ? legacyTools : smartTools;
```

**Missing Strategies:**
- **Eager vs. Lazy:** When should registry be built?
  - Eager (current): Build entire tool list at module load
  - Lazy: Build on first request
  - Hybrid: Build on demand per mode

- **Initialization Pattern:** How to initialize?
  - Function: `initToolRegistry(mode: 'legacy' | 'smart')`
  - Class: `new ToolRegistry(mode, toolDefs)`
  - Singleton: `toolRegistry.register(tool, handler)`

- **Factory Pattern:** How to create tool handlers?
  - Static imports (current)
  - Dynamic requires
  - Registry factory functions

### 2.4 Test Coverage Gaps

**Current Testing:** Based on repo examination, no visible test files specifically for:

- Tool routing logic (handler dispatch)
- Tool registry behavior (if it existed)
- Feature toggle mechanics (both modes load correctly)
- Error classification (edge cases)
- Tool argument type casting

**What's Missing:**
- Unit tests for tool routing
- Tests that both modes produce identical tools lists (except mode-specific ones)
- Registry initialization tests
- Tool lookup performance benchmarks

---

## PART 3: WHAT NEEDS CHANGES

### 3.1 Files Requiring Modification

#### File: `src/index.ts` (PRIMARY)

**Lines Affected:** 1010-1182 (routing handler)

**Current Problems:**
- 98 case statements in legacy mode (lines 1016-1114)
- 65 case statements in smart mode (lines 1117-1182)
- Duplicated arg casting: `args as Parameters<typeof toolName>[0]`
- Type assertions lose type safety information
- No way to reuse routing logic across modes

**Changes Required:**

1. **Replace switch statement** (1016-1182) with registry lookup:
   ```typescript
   // Before (165 lines)
   if (USE_LEGACY_TOOLS) {
     switch (name) { case 'chrome_connect': return await chromeConnect(...); ... }
   } else {
     switch (name) { case 'chrome': return await chrome(...); ... }
   }

   // After (5 lines)
   const handler = toolRegistry.getHandler(name);
   if (!handler) throw new Error(`Unknown tool: ${name}`);
   return await handler.invoke(args);
   ```

2. **Move feature toggle logic** into registry initialization:
   ```typescript
   // Load tools array
   const tools = USE_LEGACY_TOOLS ? legacyTools : smartTools;
   // Initialize registry with active tools
   const toolRegistry = createToolRegistry(tools, toolImplementations);
   ```

3. **Extract type casting** into registry handler:
   - Registry knows tool's argument type
   - Handler validates/casts args before invoking
   - Type information preserved per tool

---

## PART 4: DEPENDENCIES AND RISKS

### 4.1 Type Safety Preservation

**Current Risk:** Type assertions lose type information

**Registry Solution:** Preserve types in handler definition

**Key Risk:** If registry type isn't generic enough, may lose type safety

**Mitigation:**
- Use `unknown` as input type (args from MCP)
- Preserve function signature in handler implementation
- Handler responsible for type casting before invoking

### 4.2 Feature Toggle Compatibility

**Current Behavior:** Switch at module load, affects both listing and routing

**Registry Requirement:** Must respect feature toggle when creating registry

**Risk:** If registry initialization doesn't respect USE_LEGACY_TOOLS, tools mismatch

**Mitigation:**
```typescript
// Load correct tool array BEFORE creating registry
const activeToolsArray = USE_LEGACY_TOOLS ? legacyTools : smartTools;
const toolRegistry = createToolRegistry(activeToolsArray, handlers);
```

### 4.3 Error Handling Preservation

**Current Flow:** Global catch → classifyError() → logErrorEvent() → return error response

**Registry Impact:** Error handling must stay at routing boundary, not move into registry

**Risk:** If error handling moves into registry, lose structured classification

**Mitigation:**
- Keep error handling in server handler (current location)
- Registry.invoke() should not catch errors
- Let errors propagate to handler's try-catch

### 4.4 Breaking Changes to Tool Behavior

**Current:** Zero breaking changes expected with registry pattern

**Why:** Registry is routing implementation detail:
- Tools stay identical
- Tool names unchanged
- Tool metadata unchanged
- Tool arguments unchanged
- Error types unchanged

**Only Change:** How handler is dispatched (switch → lookup)

---

## PART 5: AMBIGUITIES AND UNKNOWNS (CRITICAL)

### 5.1 Should toolMetadata be extracted to separate file?

**Current State:** toolMetadata is in `src/index.ts:72-333`

**Question:** Extract to `src/toolMetadata.ts` or keep in index.ts?

**Option A: Keep in index.ts**
- Pro: Single file for tool registration
- Pro: Simpler imports
- Con: Large index.ts file (already 1219 lines before registry)
- Con: Mixes metadata with server setup

**Option B: Extract to src/toolMetadata.ts**
- Pro: Single responsibility
- Pro: Easier to maintain tool definitions
- Pro: Can import toolMetadata in multiple places
- Con: Additional file to manage
- Con: Need to be careful about circular imports

**Recommendation:** Extract to separate file as phase 2 improvement (after registry works)

**Decision Needed:** Before implementation, discuss with team

### 5.2 How to handle args type casting in registry?

**Challenge:** Tools have different argument types, registry receives `unknown`

**Current approach:**
```typescript
// Each case handles type casting
case 'chrome_connect':
  return await chromeConnect(args as Parameters<typeof chromeConnect>[0]);
```

**Registry approaches:**

**Option A: Cast in handler definition**
```typescript
invoke: async (args: unknown) => {
  return await chromeConnect(args as Parameters<typeof chromeConnect>[0]);
}
```
- Pro: Type info preserved in handler
- Pro: No shared logic needed
- Con: Duplicate casting in each handler

**Option B: Generic type parameter**
```typescript
interface ToolHandler<T = unknown> {
  invoke(args: T): Promise<ToolResult>;
}
```
- Pro: More type-safe
- Con: Can't use uniform invoke signature

**Option C: Validation schema in registry**
```typescript
invoke: async (args: unknown) => {
  const validated = validateArgs(args, inputSchema);
  return await chromeConnect(validated as Parameters<typeof chromeConnect>[0]);
}
```
- Pro: Separate validation from invocation
- Pro: Reusable validation
- Con: Adds complexity

**Recommendation:** Option A (cast in handler) matches current approach, lowest risk

**Decision Needed:** Confirm type casting strategy before implementation

### 5.3 Should registry be initialized at module load or lazily?

**Option A: Eager Initialization (at module load)**
```typescript
// At top of index.ts
const toolRegistry = createToolRegistry(activeTools, createHandlers());
```

**Pros:**
- Fast tool lookup (no initialization on first call)
- Errors surface immediately at startup
- Deterministic behavior

**Cons:**
- Extra overhead at startup
- May load tools that never get used

**Option B: Lazy Initialization (on first request)**
```typescript
let toolRegistry: ToolRegistry | null = null;

function getRegistry(): ToolRegistry {
  if (!toolRegistry) {
    toolRegistry = createToolRegistry(activeTools, createHandlers());
  }
  return toolRegistry;
}
```

**Pros:**
- Faster startup time
- Only load tools that are used

**Cons:**
- First tool call is slower (initialization overhead)
- Potential race conditions if multiple tools called simultaneously
- Errors surface later (harder to debug at startup)

**Recommendation:** Eager initialization (Option A) - matches current behavior

**Decision Needed:** Confirm initialization timing

### 5.4 Testing strategy for both legacy and smart modes?

**Current State:** No visible tool routing tests

**Question:** How to test registry with both modes?

**Option A: Test with environment variable**
**Option B: Test with parameterized test**
**Option C: Test registry function, not module initialization**

**Recommendation:** Option C (test registry function in isolation)

**Decision Needed:** Confirm testing approach

### 5.5 Migration path and validation approach?

**Question:** How to validate registry works before removing switch statements?

**Option A: Parallel implementation (safest)**
- Keep switch statement
- Add registry in parallel
- Compare results from both paths
- Eventually remove switch statement

**Option B: Phased migration (faster)**
- Phase 1: Create registry
- Phase 2: Use registry in one mode (e.g., smart)
- Phase 3: Migrate legacy mode
- Phase 4: Remove switch statements

**Option C: Big bang replacement (fastest, riskiest)**
- Create registry
- Remove all switch statements
- Test immediately

**Recommendation:** Option A (parallel) for safety, then Option C (cleanup)

**Decision Needed:** Confirm migration strategy

---

## PART 6: DESIGN DECISIONS REQUIRED BEFORE IMPLEMENTATION

| Question | Current State | Options | Impact |
|----------|---------------|---------|--------|
| Extract toolMetadata to separate file? | In index.ts:72-333 | A: Keep in index | High complexity if moved later |
| Type casting strategy in registry? | Case-by-case in switch | A: In handler, B: Shared validation | Type safety, maintainability |
| Initialization timing? | At module load (eager) | A: Eager (current), B: Lazy | Startup time, error handling |
| Test strategy for modes? | No visible tests | A: Env var, B: Parameterized, C: Unit test registry | Test coverage, maintainability |
| Migration path? | Must create plan | A: Parallel, B: Phased, C: Big bang | Risk level, validation complexity |
| Should registry be exported? | Currently internal | A: Internal, B: Export for testing | Testability, encapsulation |
| Error handling ownership? | Handler (current) | A: Keep in handler, B: Move to registry | Separation of concerns |

---

## VERDICT: CONTINUE

**Confidence Level:** HIGH (clear path, well-defined ambiguities)

**Recommendation:** Proceed to implementation planning with following decisions:

1. ✅ Extract toolMetadata to separate file (Phase 2 improvement, not required for v1)
2. ✅ Type casting in handler definitions (Option A - lowest risk)
3. ✅ Eager initialization (matches current behavior)
4. ✅ Unit test registry function in isolation (Option C)
5. ✅ Parallel implementation approach (safety first, then cleanup)
6. ✅ Keep error handling in server handler (preserve current architecture)

**Next Steps:**
1. Resolve ambiguities with team
2. Create implementation plan with specific file/line changes
3. Define acceptance criteria for registry behavior
4. Schedule sprint planning
5. Begin Phase 1 (Registry module)

**Expected Outcome:** Extensible tool registry pattern while maintaining 100% backward compatibility with feature toggle modes.

---

**Evaluation Date:** 2026-01-20
**Timestamp:** 20260120-093519
**Evaluator:** Code Analysis
**Next Review:** After implementation planning decisions
