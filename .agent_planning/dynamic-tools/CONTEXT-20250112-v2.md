# Implementation Context - Smart Tool Design
Date: 2025-01-12 (v2)

## Summary

Redesign cherry-chrome-mcp to be AI-agent optimized:
1. **Consolidate 23 tools → 15** by combining related actions
2. **Dynamic visibility** with 4 states (2/12/15/5 tools)
3. **Smart responses** that auto-include anticipated context

## Current File Structure

```
src/
├── index.ts          # MCP server, tool registration (lines 57-521 = tool defs)
├── browser.ts        # BrowserManager class, connection state
├── tools/
│   ├── chrome.ts     # chromeConnect, chromeLaunch, listTargets, switchTarget
│   ├── dom.ts        # queryElements, clickElement, fillElement, navigate, getConsoleLogs
│   └── debugger.ts   # All debugger_* tools
```

## Tool Consolidation Map

### chrome.ts changes:
```typescript
// NEW: chrome() - replaces chromeConnect + chromeLaunch
export async function chrome(args: {
  action: 'connect' | 'launch';
  port?: number;
  host?: string;
  headless?: boolean;
  connection_id?: string;
  // ... other params from both originals
})

// NEW: target() - replaces listTargets + switchTarget
export async function target(args: {
  action: 'list' | 'switch';
  index?: number;
  title?: string;
  url?: string;
  connection_id?: string;
})

// NEW: enable_debug_tools() - shows debugger tools
export async function enableDebugTools(args: { connection_id?: string })

// NEW: hide_tools() - hide by name or pattern
export async function hideTools(args: {
  tools?: string[];      // specific tool names
  pattern?: string;      // glob pattern like "debugger_*"
})

// NEW: show_tools() - restore hidden
export async function showTools(args: {
  tools?: string[];      // specific tools
  all?: boolean;         // restore all
})
```

### debugger.ts changes:
```typescript
// NEW: step() - replaces step_over, step_into, step_out
export async function step(args: {
  direction: 'over' | 'into' | 'out';
  include_context?: boolean;  // default true
  connection_id?: string;
})

// NEW: execution() - replaces resume, pause
export async function execution(args: {
  action: 'resume' | 'pause';
  include_context?: boolean;
  connection_id?: string;
})

// NEW: breakpoint() - replaces set/remove
export async function breakpoint(args: {
  action: 'set' | 'remove';
  url?: string;           // for set
  line_number?: number;   // for set
  breakpoint_id?: string; // for remove
  condition?: string;     // for set
  connection_id?: string;
})
```

## Dynamic Visibility Implementation

### State tracking (browser.ts):
```typescript
// Add to BrowserManager class:
private hiddenTools: Set<string> = new Set();

hideTools(tools: string[]): void {
  tools.forEach(t => this.hiddenTools.add(t));
}

showTools(tools?: string[]): void {
  if (!tools) {
    this.hiddenTools.clear();
  } else {
    tools.forEach(t => this.hiddenTools.delete(t));
  }
}

isToolHidden(name: string): boolean {
  return this.hiddenTools.has(name);
}
```

### Visibility rules (index.ts):
```typescript
function getVisibleTools(): ToolDefinition[] {
  const hasConn = browserManager.hasConnections();
  const debugEnabled = browserManager.getActive()?.debuggerEnabled ?? false;
  const isPaused = browserManager.isPaused();

  let tools: ToolDefinition[] = [];

  if (isPaused) {
    // Minimal stepping set
    tools = [STEP, EXECUTION, EVALUATE, CALL_STACK, SHOW_TOOLS];
  } else if (debugEnabled) {
    // Full debug set
    tools = [...CONNECTION_TOOLS, ...DOM_TOOLS, ...DEBUG_TOOLS, ...META_TOOLS];
  } else if (hasConn) {
    // Connected, no debug
    tools = [...CONNECTION_TOOLS, ...DOM_TOOLS, ENABLE_DEBUG, ...META_TOOLS];
  } else {
    // Not connected
    tools = [CHROME, CHROME_LIST_CONNECTIONS];
  }

  // Apply user hidden
  return tools.filter(t => !browserManager.isToolHidden(t.name));
}
```

### Notification triggers:
```typescript
// In chrome.ts - after successful connect/launch:
await server.sendToolListChanged();

// In chrome.ts - after disconnect when last connection:
if (!browserManager.hasConnections()) {
  await server.sendToolListChanged();
}

// In debugger.ts - after enableDebugTools:
await server.sendToolListChanged();

// In browser.ts - CDP event handlers:
client.on('Debugger.paused', async () => {
  connection.pausedData = params;
  await server.sendToolListChanged();  // Switch to stepping mode
});

client.on('Debugger.resumed', async () => {
  connection.pausedData = null;
  await server.sendToolListChanged();  // Restore full tools
});
```

## Smart Response Implementation

### New file: src/tools/context.ts
```typescript
import { browserManager } from '../browser.js';

export interface PauseContext {
  location: { file: string; line: number; function: string };
  callStack: Array<{ function: string; file: string; line: number }>;
  localVariables: Record<string, string>;  // truncated values
  recentConsole: Array<{ level: string; message: string }>;
}

export async function gatherPauseContext(connectionId?: string): Promise<PauseContext> {
  const connection = browserManager.getConnection(connectionId);
  const pausedData = connection?.pausedData;
  if (!pausedData) throw new Error('Not paused');

  const cdp = connection.cdpSession;

  // Get call stack from pausedData.callFrames
  const callStack = pausedData.callFrames.slice(0, 5).map(f => ({
    function: f.functionName || '(anonymous)',
    file: f.url.split('/').pop() || f.url,
    line: f.location.lineNumber + 1
  }));

  // Get local variables from first frame
  const frame = pausedData.callFrames[0];
  const localScope = frame.scopeChain.find(s => s.type === 'local');
  let localVariables: Record<string, string> = {};

  if (localScope) {
    const props = await cdp.send('Runtime.getProperties', {
      objectId: localScope.object.objectId,
      ownProperties: true
    });
    localVariables = Object.fromEntries(
      props.result.slice(0, 10).map(p => [
        p.name,
        truncateValue(p.value?.description || p.value?.value || 'undefined')
      ])
    );
  }

  // Get recent console
  const recentConsole = browserManager.getConsoleLogs(connectionId).slice(-3).map(l => ({
    level: l.level,
    message: l.text.substring(0, 100)
  }));

  return {
    location: {
      file: frame.url.split('/').pop() || frame.url,
      line: frame.location.lineNumber + 1,
      function: frame.functionName || '(anonymous)'
    },
    callStack,
    localVariables,
    recentConsole
  };
}

function truncateValue(val: string, max = 100): string {
  return val.length > max ? val.substring(0, max) + '...' : val;
}

export function formatPauseContext(ctx: PauseContext): string {
  const lines: string[] = [];

  lines.push(`Paused at: ${ctx.location.file}:${ctx.location.line} (${ctx.location.function})`);
  lines.push('');
  lines.push('Call Stack:');
  ctx.callStack.forEach((f, i) => {
    lines.push(`  [${i}] ${f.function} (${f.file}:${f.line})${i === 0 ? ' <- current' : ''}`);
  });
  lines.push('');
  lines.push('Local Variables:');
  Object.entries(ctx.localVariables).forEach(([k, v]) => {
    lines.push(`  ${k} = ${v}`);
  });
  if (ctx.recentConsole.length > 0) {
    lines.push('');
    lines.push('Recent Console:');
    ctx.recentConsole.forEach(l => {
      lines.push(`  [${l.level.toUpperCase()}] ${l.message}`);
    });
  }

  return lines.join('\n');
}
```

### Using context in step/execution:
```typescript
// In debugger.ts step():
export async function step(args: {
  direction: 'over' | 'into' | 'out';
  include_context?: boolean;
  connection_id?: string;
}) {
  const includeContext = args.include_context ?? true;
  const cdp = browserManager.getCdpSession(args.connection_id);

  // Execute step
  const method = {
    over: 'Debugger.stepOver',
    into: 'Debugger.stepInto',
    out: 'Debugger.stepOut'
  }[args.direction];

  await cdp.send(method);

  // Wait for pause
  await waitForPause(args.connection_id);

  if (includeContext) {
    const ctx = await gatherPauseContext(args.connection_id);
    return successResponse(`Stepped ${args.direction}\n\n${formatPauseContext(ctx)}`);
  }

  return successResponse(`Stepped ${args.direction}`);
}
```

## Tool Categories for Visibility

```typescript
// In index.ts or new tools/definitions.ts:

const CONNECTION_TOOLS = ['chrome', 'chrome_list_connections', 'chrome_disconnect', 'target'];
const DOM_TOOLS = ['query_elements', 'click_element', 'fill_element', 'navigate', 'get_console_logs'];
const DEBUG_TOOLS = ['breakpoint', 'execution', 'step', 'evaluate', 'call_stack', 'pause_on_exceptions'];
const META_TOOLS = ['hide_tools', 'show_tools'];
const STEPPING_TOOLS = ['step', 'execution', 'evaluate', 'call_stack', 'show_tools'];
```

## Testing Checklist

1. **Tool consolidation**
   - `chrome(action: "launch")` works
   - `chrome(action: "connect")` works
   - `target(action: "list")` shows targets
   - `target(action: "switch", index: 0)` switches
   - `step(direction: "over")` steps and returns context
   - `execution(action: "pause")` pauses
   - `breakpoint(action: "set", ...)` sets breakpoint

2. **Visibility states**
   - Fresh start: 2 tools
   - After connect: 12 tools
   - After enable_debug: 15 tools
   - After hitting breakpoint: 5 tools
   - After resume: back to 15

3. **Smart responses**
   - Hit breakpoint → see call stack, vars, console
   - Step over → see new location, var changes
   - Navigate → see title, errors
