# Dynamic MCP Tool Visibility - Implementation Context
**Date:** 2025-01-12  
**Topic Directory:** `.agent_planning/dynamic-tools/`

## Overview

This document provides detailed implementation context for adding dynamic tool visibility to cherry-chrome-mcp. It maps the plan deliverables to specific code locations and provides implementation patterns.

---

## Key Files and Locations

### Files to Create

1. **`src/tools/definitions.ts`** (new)
   - Purpose: Extract all tool definitions from inline handler
   - Exports: `const ALL_TOOLS: ToolDefinition[]`
   - Source: Extract from `src/index.ts` lines 57-521
   - Pattern:
     ```typescript
     import { Tool } from '@modelcontextprotocol/sdk/types.js';
     
     export const ALL_TOOLS: Tool[] = [
       {
         name: 'chrome_connect',
         description: '...',
         inputSchema: { type: 'object', properties: {...}, required: [...] }
       },
       // ... all 23 tools
     ];
     ```

2. **`src/tools/visibility.ts`** (new)
   - Purpose: Visibility rules and state checking
   - Exports:
     - `interface ToolState`
     - `function getToolState(browserManager: BrowserManager): ToolState`
     - `function getVisibleTools(state: ToolState): Tool[]`
   - Pattern:
     ```typescript
     import { BrowserManager } from '../browser.js';
     import { ALL_TOOLS } from './definitions.js';
     import { Tool } from '@modelcontextprotocol/sdk/types.js';
     
     export interface ToolState {
       connectionCount: number;
       hasActiveConnection: boolean;
       debuggerEnabled: boolean;
       isPaused: boolean;
     }
     
     export function getToolState(browserManager: BrowserManager): ToolState {
       const active = browserManager.getActive();
       return {
         connectionCount: browserManager.listConnections().length,
         hasActiveConnection: active !== null,
         debuggerEnabled: active?.debuggerEnabled ?? false,
         isPaused: active?.pausedData !== null
       };
     }
     
     type VisibilityRule = (state: ToolState) => boolean;
     
     const VISIBILITY_RULES: Record<string, VisibilityRule> = {
       // Connection tools
       chrome_connect: () => true,
       chrome_launch: () => true,
       chrome_list_connections: () => true,
       chrome_disconnect: (s) => s.hasActiveConnection,
       chrome_switch_connection: (s) => s.connectionCount >= 2,
       
       // Target management
       list_targets: (s) => s.hasActiveConnection,
       switch_target: (s) => s.hasActiveConnection,
       
       // DOM tools
       query_elements: (s) => s.hasActiveConnection,
       click_element: (s) => s.hasActiveConnection,
       fill_element: (s) => s.hasActiveConnection,
       navigate: (s) => s.hasActiveConnection,
       get_console_logs: (s) => s.hasActiveConnection,
       
       // Debugger tools (not paused)
       debugger_enable: (s) => s.hasActiveConnection && !s.debuggerEnabled,
       debugger_pause: (s) => s.debuggerEnabled && !s.isPaused,
       debugger_set_breakpoint: (s) => s.debuggerEnabled,
       debugger_remove_breakpoint: (s) => s.debuggerEnabled,
       debugger_set_pause_on_exceptions: (s) => s.debuggerEnabled,
       
       // Stepping tools (paused only)
       debugger_resume: (s) => s.isPaused,
       debugger_step_over: (s) => s.isPaused,
       debugger_step_into: (s) => s.isPaused,
       debugger_step_out: (s) => s.isPaused,
       debugger_get_call_stack: (s) => s.isPaused,
       debugger_evaluate_on_call_frame: (s) => s.isPaused,
     };
     
     export function getVisibleTools(state: ToolState): Tool[] {
       return ALL_TOOLS.filter(tool => {
         const rule = VISIBILITY_RULES[tool.name];
         if (!rule) {
           console.warn(`No visibility rule for tool: ${tool.name}`);
           return true; // Default to visible if no rule
         }
         return rule(state);
       });
     }
     ```

### Files to Modify

1. **`src/browser.ts`** - Add EventEmitter
   - **Line 1-10:** Add import: `import { EventEmitter } from 'events';`
   - **Line 66:** Change class declaration:
     ```typescript
     export class BrowserManager extends EventEmitter {
       constructor() {
         super();
         // ... existing constructor code
       }
     }
     ```
   - **Emit locations:**
     - Line ~111 in `connect()`: Add `this.emit('stateChanged');` after `this.activeConnectionId = connectionId;`
     - Line ~199 in `launch()`: Add `this.emit('stateChanged');` after `this.activeConnectionId = connectionId;`
     - Line ~290 in `disconnect()`: Add `this.emit('stateChanged');` after connection removal
     - Line ~359 in `switchActive()`: Add `this.emit('stateChanged');` after `this.activeConnectionId = connectionId;`
     - Line ~432 in `enableDebugger()`: Add `this.emit('stateChanged');` after `connection.debuggerEnabled = true;`
     - Line ~557 in `switchPage()`: Add `this.emit('stateChanged');` after resetting debugger state
     - Line ~425 in `enableDebugger()` inside `Debugger.paused` handler: Add `this.emit('stateChanged');` after `connection.pausedData = params;`
     - Line ~430 in `enableDebugger()` inside `Debugger.resumed` handler: Add `this.emit('stateChanged');` after `connection.pausedData = null;`

2. **`src/index.ts`** - Update handler and subscribe
   - **Line ~10-20:** Add imports:
     ```typescript
     import { getToolState, getVisibleTools } from './tools/visibility.js';
     import { browserManager } from './browser.js';
     ```
   - **Line 57-521:** Replace entire ListToolsRequestSchema handler:
     ```typescript
     server.setRequestHandler(ListToolsRequestSchema, async () => {
       const state = getToolState(browserManager);
       const visibleTools = getVisibleTools(state);
       return { tools: visibleTools };
     });
     ```
   - **Line ~585 (after server creation, before server.connect()):** Add subscription:
     ```typescript
     // Subscribe to state changes
     browserManager.on('stateChanged', async () => {
       try {
         await server.sendToolListChanged();
       } catch (error) {
         console.error('Failed to send tool list changed notification:', error);
       }
     });
     ```

---

## Tool Categories and State Requirements

| Category | Tools | State Requirement |
|----------|-------|------------------|
| **Connection** (always) | chrome_connect, chrome_launch, chrome_list_connections | None (always visible) |
| **Connection** (conditional) | chrome_disconnect | hasActiveConnection |
| **Connection** (multi) | chrome_switch_connection | connectionCount >= 2 |
| **Target Management** | list_targets, switch_target | hasActiveConnection |
| **DOM Interaction** | query_elements, click_element, fill_element, navigate, get_console_logs | hasActiveConnection |
| **Debugger Enablement** | debugger_enable | hasActiveConnection && !debuggerEnabled |
| **Debugger Control** | debugger_pause, debugger_set_breakpoint, debugger_remove_breakpoint, debugger_set_pause_on_exceptions | debuggerEnabled && !isPaused |
| **Debugger Stepping** | debugger_resume, debugger_step_over, debugger_step_into, debugger_step_out, debugger_get_call_stack, debugger_evaluate_on_call_frame | isPaused |

---

## State Properties in BrowserManager

| Property | Type | Location | Purpose |
|----------|------|----------|---------|
| `connections` | `Map<string, Connection>` | Line 69 | All active connections |
| `activeConnectionId` | `string \| null` | Line 70 | Currently active connection ID |
| `connection.debuggerEnabled` | `boolean` | Line 128 | Per-connection debugger state |
| `connection.pausedData` | `DebuggerPausedEvent \| null` | Line 126 | Set when paused at breakpoint |

### State Query Methods (Already Exist)

- `hasConnections(): boolean` - Line 388
- `listConnections(): Connection[]` - Line 363
- `getActive(): Connection \| null` - Line 313
- `isPaused(): boolean` - Line 481

---

## MCP SDK Methods

From `@modelcontextprotocol/sdk`:

```typescript
// Server class method
async sendToolListChanged(): Promise<void>
```

**Protocol flow:**
1. Server calls `server.sendToolListChanged()`
2. SDK sends `notifications/tools/list_changed` to client
3. Client requests updated tool list via `tools/list`
4. Server's ListToolsRequestSchema handler runs
5. Handler returns tools based on current state

---

## State Change Events

All methods that modify state must emit `stateChanged`:

| Method | Location | When to Emit | Reason |
|--------|----------|--------------|---------|
| `connect()` | Line 80 | After connection added | New connection available |
| `launch()` | Line 175 | After browser launched | New connection available |
| `disconnect()` | Line 268 | After connection removed | Connection no longer available |
| `switchActive()` | Line 349 | After active changed | Different connection may have different debugger state |
| `enableDebugger()` | Line 398 | After debugger enabled | Debugger tools now available |
| `switchPage()` | Line 529 | After page switched | Debugger state reset |
| CDP `Debugger.paused` handler | Line ~425 | After pausedData set | Stepping tools now available |
| CDP `Debugger.resumed` handler | Line ~430 | After pausedData cleared | Stepping tools no longer available |

---

## Testing Workflow

### 1. Initial State (No Connections)
```
Expected visible tools (3):
- chrome_connect
- chrome_launch
- chrome_list_connections
```

### 2. After chrome_launch
```
Expected visible tools (11):
- chrome_connect
- chrome_launch
- chrome_list_connections
- chrome_disconnect
- list_targets
- switch_target
- query_elements
- click_element
- fill_element
- navigate
- get_console_logs
```

### 3. After debugger_enable
```
Expected visible tools (16):
- (all from state 2) +
- debugger_enable
- debugger_pause
- debugger_set_breakpoint
- debugger_remove_breakpoint
- debugger_set_pause_on_exceptions
```

### 4. After Hitting Breakpoint (Paused)
```
Expected visible tools (22):
- (all from state 3, minus debugger_pause) +
- debugger_resume
- debugger_step_over
- debugger_step_into
- debugger_step_out
- debugger_get_call_stack
- debugger_evaluate_on_call_frame
```

### 5. After Second chrome_launch (Multiple Connections)
```
Expected visible tools (23):
- (all from state 2 or 3) +
- chrome_switch_connection
```

---

## Error Handling

### EventEmitter Subscription
```typescript
browserManager.on('stateChanged', async () => {
  try {
    await server.sendToolListChanged();
  } catch (error) {
    console.error('Failed to send tool list changed notification:', error);
    // Don't rethrow - state change already happened, notification is best-effort
  }
});
```

### Missing Visibility Rule
```typescript
export function getVisibleTools(state: ToolState): Tool[] {
  return ALL_TOOLS.filter(tool => {
    const rule = VISIBILITY_RULES[tool.name];
    if (!rule) {
      console.warn(`No visibility rule for tool: ${tool.name}`);
      return true; // Default to visible if no rule
    }
    return rule(state);
  });
}
```

---

## Implementation Notes

1. **EventEmitter is built-in**: No need to add dependencies, `EventEmitter` is from Node.js `events` module
2. **Connection state includes debugger state**: When checking debugger state, always query the active connection
3. **Paused state is per-connection**: Different connections can have different pause states
4. **Line numbers are 0-indexed in CDP**: This doesn't affect visibility, but important for debugger tools
5. **Tool names must match exactly**: Visibility rules use tool names as keys, ensure consistency
6. **No caching needed initially**: Visibility check is fast, optimize later if needed

---

## Rollback Context

If implementation needs to be reverted:

1. **Restore original handler in `src/index.ts`:**
   - Revert lines 57-521 to original inline tool list
   - Remove imports of visibility functions
   - Remove browserManager subscription

2. **Revert BrowserManager changes in `src/browser.ts`:**
   - Remove `extends EventEmitter`
   - Remove all `this.emit('stateChanged')` calls
   - Remove EventEmitter import

3. **Delete new files:**
   - `src/tools/definitions.ts`
   - `src/tools/visibility.ts`

4. **Rebuild:**
   - `npm run build`
   - All tools will be visible again (original behavior)

