# Sprint Plan: Cherry Chrome MCP - Smart Tool Design
Generated: 2025-01-12 (v2 - comprehensive redesign)

## Sprint Goal
Redesign cherry-chrome MCP for minimal context overhead and maximum debugging efficiency through consolidated tools, dynamic visibility, and smart auto-bundled responses.

## Key Design Principles
1. **Fewer tools** - Consolidate related actions into single tools with action parameters
2. **Dynamic visibility** - Show only relevant tools for current state
3. **Smart responses** - Auto-include context that eliminates follow-up tool calls
4. **Stepping efficiency** - Minimize tool count when paused (most tool-call-intensive state)

---

## P0: Tool Consolidation

Reduce 23 tools to ~12 by combining related actions.

### Consolidated Tool Design

| New Tool | Replaces | Parameters |
|----------|----------|------------|
| `chrome` | chrome_connect, chrome_launch | `action: "connect" \| "launch"`, port, host, headless, etc. |
| `target` | list_targets, switch_target | `action: "list" \| "switch"`, index/title/url |
| `step` | debugger_step_over, step_into, step_out | `direction: "over" \| "into" \| "out"` |
| `execution` | debugger_resume, debugger_pause | `action: "resume" \| "pause"` |
| `breakpoint` | debugger_set_breakpoint, remove_breakpoint | `action: "set" \| "remove"`, url, line, condition |

### Tools That Stay Separate
- `chrome_list_connections` - simple, always needed
- `chrome_disconnect` - destructive, keep explicit
- `query_elements` - complex params, keep as-is
- `click_element` - keep separate (clear intent)
- `fill_element` - keep separate (clear intent)
- `navigate` - keep separate
- `get_console_logs` - keep separate (explicit fetch)
- `evaluate` - keep (was debugger_evaluate_on_call_frame)
- `call_stack` - keep (was debugger_get_call_stack)
- `pause_on_exceptions` - keep (was debugger_set_pause_on_exceptions)

### New Meta-Tools
- `enable_debug_tools` - Shows debugger tools (semantic intent)
- `hide_tools` - Hide tools by name or pattern: `hide_tools(pattern: "chrome_*")`
- `show_tools` - Restore hidden tools: `show_tools(all: true)` or `show_tools(tools: [...])`

### Final Tool List (~15 tools)
1. `chrome` (connect/launch)
2. `chrome_list_connections`
3. `chrome_disconnect`
4. `target` (list/switch)
5. `query_elements`
6. `click_element`
7. `fill_element`
8. `navigate`
9. `get_console_logs`
10. `enable_debug_tools`
11. `hide_tools`
12. `show_tools`
13. `breakpoint` (set/remove)
14. `execution` (resume/pause)
15. `step` (over/into/out)
16. `evaluate`
17. `call_stack`
18. `pause_on_exceptions`

---

## P1: Dynamic Tool Visibility

### State-Based Visibility

| State | Visible Tools | Count |
|-------|---------------|-------|
| **Not connected** | chrome, chrome_list_connections | 2 |
| **Connected** | + chrome_disconnect, target, query_elements, click_element, fill_element, navigate, get_console_logs, enable_debug_tools, hide_tools, show_tools | 12 |
| **Debug enabled** | + breakpoint, execution, pause_on_exceptions | 15 |
| **Paused** | step, execution, evaluate, call_stack, show_tools | **5** |

### Implementation
- Track state in BrowserManager (already has: hasConnections, debuggerEnabled, pausedData)
- `ListToolsRequestSchema` handler checks state, returns appropriate subset
- Call `server.sendToolListChanged()` on state transitions:
  - connect/launch success
  - disconnect (when last connection)
  - enable_debug_tools called
  - Debugger.paused event
  - Debugger.resumed event

### User Override
- `hide_tools` / `show_tools` maintained in `hiddenTools: Set<string>`
- Applied on top of state-based visibility
- Persists until explicitly changed or connection reset

---

## P2: Smart Auto-Bundled Responses

Eliminate follow-up tool calls by including anticipated context.

### Breakpoint/Pause Hit
When execution pauses (breakpoint, exception, manual pause), auto-include:
```
Paused at: {file}:{line} ({function_name})
Reason: {breakpoint | exception | pause}

Call Stack:
  [0] {function} ({file}:{line}) <- current
  [1] {function} ({file}:{line})
  ...

Local Variables:
  {name} = {value}  (top 10, truncated values)

Recent Console (last 3):
  [{level}] {message}
```

### Step Response
After any step (over/into/out), auto-include:
```
Stepped to: {file}:{line} ({function_name})

Local Variables:
  {name} = {value}
  {name} = {value} [CHANGED from {old_value}]

New Console (since last step):
  [{level}] {message}
```

### Exception Response
When paused on exception:
```
Exception: {type}: {message}

at {file}:{line}

Call Stack:
  [0] {function} ({file}:{line})
  ...

Recent Console (last 3):
  ...
```

### Navigate Response
After navigation completes:
```
Navigated to: {url}
Title: {page_title}

Console Errors (if any):
  [ERROR] {message}

Page Summary:
  - {count} buttons
  - {count} inputs
  - {count} links
```

### Click/Fill Response
After DOM action:
```
Clicked: <button> "Submit"

Console (triggered by action):
  [LOG] Form submitted
  [ERROR] Validation failed  <- if any errors

Element State:
  Visible: true
  Disabled: false
```

### Implementation
- Each tool handler gathers relevant context before returning
- Use `include_context: boolean` param (default: true) for opt-out
- Context gathering uses existing CDP session
- Truncate large values (>100 chars), limit arrays (first 5 items)

---

## Acceptance Criteria (DOD)

### P0: Tool Consolidation
- [ ] `chrome` tool handles connect and launch with action parameter
- [ ] `target` tool handles list and switch with action parameter
- [ ] `step` tool handles over/into/out with direction parameter
- [ ] `execution` tool handles resume/pause with action parameter
- [ ] `breakpoint` tool handles set/remove with action parameter
- [ ] All consolidated tools work correctly
- [ ] Old tool names removed from registration
- [ ] TypeScript compiles without errors

### P1: Dynamic Visibility
- [ ] Not connected: only 2 tools visible
- [ ] Connected: 12 tools visible
- [ ] Debug enabled: 15 tools visible
- [ ] Paused: only 5 tools visible
- [ ] `hide_tools` hides specified tools
- [ ] `show_tools` restores hidden tools
- [ ] Tool list updates automatically on state change (no restart)

### P2: Smart Responses
- [ ] Pause/breakpoint includes: call stack, local vars, last 3 console logs
- [ ] Step includes: new location, local vars (with change markers), new console
- [ ] Navigate includes: title, console errors, page summary
- [ ] Click/fill includes: triggered console logs, element state
- [ ] `include_context: false` disables auto-bundling

---

## Files to Modify

### src/index.ts
- Update ListToolsRequestSchema handler for dynamic visibility
- Add state change event subscriptions
- Register new consolidated tools, remove old ones

### src/tools/chrome.ts
- Consolidate chromeConnect + chromeLaunch → `chrome()`
- Add `listTargets` + `switchTarget` → `target()`
- Add `hide_tools`, `show_tools`, `enable_debug_tools`

### src/tools/debugger.ts
- Consolidate step_* → `step()`
- Consolidate resume/pause → `execution()`
- Consolidate set/remove breakpoint → `breakpoint()`
- Add smart context gathering to pause/step responses

### src/tools/dom.ts
- Add smart context to navigate response
- Add smart context to click/fill responses

### src/browser.ts
- Add `hiddenTools: Set<string>` state
- Emit events on state changes for visibility updates

### New: src/tools/context.ts
- `gatherPauseContext()` - call stack, locals, console
- `gatherStepContext()` - location, locals with diff, new console
- `gatherNavigateContext()` - title, errors, summary
- `gatherActionContext()` - triggered logs, element state

---

## Estimated Effort

| Phase | Effort |
|-------|--------|
| P0: Tool consolidation | 2 hours |
| P1: Dynamic visibility | 1 hour |
| P2: Smart responses | 2 hours |
| Testing | 1 hour |
| **Total** | **6 hours** |

---

## Risks

1. **Breaking changes** - Consolidated tools have different signatures
   - Mitigation: This is a dev tool, breaking changes acceptable

2. **Context gathering latency** - Smart responses add CDP calls
   - Mitigation: Parallel fetching, reasonable limits on data

3. **Large context responses** - Could be too verbose
   - Mitigation: Truncation, limits, opt-out flag

---

## Future Enhancements (Not This Sprint)

- Persistent tool preferences across sessions
- Custom context templates per user
- Streaming responses for large context
- Tool usage analytics
